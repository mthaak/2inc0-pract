/* 
 * Operating Systems  (2INC0)  Practical Assignment
 * Condition Variables Application
 *
 * STUDENT_NAME_1 (STUDENT_NR_1)
 * STUDENT_NAME_2 (STUDENT_NR_2)
 *
 * Grading:
 * Students who hand in clean code that fully satisfies the minimum requirements will get an 8. 
 * Extra steps can lead to higher marks because we want students to take the initiative. 
 * Extra steps can be, for example, in the form of measurements added to your code, a formal 
 * analysis of deadlock freeness etc.
 */
 
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <unistd.h>
#include <string.h> // for to_binary
#include <pthread.h>

#include "prodcons.h"

/* buffer[]
 * circular buffer that holds the items generated by the producer and
 * which have to be retrieved by consumers
 */
static ITEM     buffer [BUFFER_SIZE];

/* number of items currently in buffer */
static int      in_buffer = 0;
/* whether producer is ready */
static bool     finished = false;

static pthread_mutex_t              mutex                       = PTHREAD_MUTEX_INITIALIZER;
static pthread_cond_t               prod_cond                   = PTHREAD_COND_INITIALIZER;
static pthread_cond_t               cons_cond[NROF_CONSUMERS];

#define ITEM_MASK(seq_nr, dest)     (((seq_nr) << NROF_BITS_DEST) | dest)
#define ITEM_TO_SEQ(mask)           (mask >> NROF_BITS_DEST)
#define ITEM_TO_DEST(mask)          (mask & ((1 << NROF_BITS_DEST) - 1)

static void rsleep (int t);

const char *to_binary(int x);

/* producer thread */
static void * producer (void * arg)
{
    ITEM    item;   // a produced item
    int total_produced = 0;
    
    while (total_produced < NROF_ITEMS)
    {
        rsleep (PRODUCER_SLEEP_FACTOR);
        
        // produce new item
        short int dest_nr = rand() % NROF_CONSUMERS;
        item = ITEM_MASK(total_produced + 1, dest_nr); 
       
        // mutex-lock;
        pthread_mutex_lock(&mutex); 
        // while not condition-for-this-producer
        while (in_buffer >= BUFFER_SIZE)
        {
            // wait-cv;
            pthread_cond_wait(&prod_cond, &mutex);
        }
        // put item into buffer
        buffer[in_buffer] = item;
        in_buffer++;
        printf("Producer: item %d produced for %d (%s)\n", total_produced, dest_nr, to_binary(item));
        // possible-cv-signals;
        pthread_cond_signal(&cons_cond[dest_nr]);
        // mutex-unlock;
        pthread_mutex_unlock(&mutex); 
        
        total_produced++;
        
        // apply this printf at the correct location in that pseudocode:
        //printf("%04x\n", item); // write info to stdout
    }
    
    // * inform consumers that we're ready
    finished = true;
    int i = 0;
    for (i = 0; i < NROF_CONSUMERS; i++)
    { 
        pthread_cond_signal(&cons_cond[i]);
    }

    return(arg);
}

/* consumer thread */
static void * consumer (void * arg)
{
    ITEM    item;   // a consumed item
    int     id;     // identifier of this consumer (value 0..NROF_CONSUMERS-1)
    
    id = (int) arg; 

    while (in_buffer > 0 || !finished)
    {
        rsleep (100 * NROF_CONSUMERS);

        // mutex-lock;
        pthread_mutex_lock(&mutex);
        // while not condition-for-this-consumer
        
        while (in_buffer <= 0 && !finished) {
            // wait-cv;
            pthread_cond_wait(&cons_cond[id], &mutex);
        } 
        // critical-section;
        // get the next item from buffer[] (intended for this customer)
        item = buffer[in_buffer - 1];
        in_buffer--; 
        printf("                                                      Consumer %d: item %d consumed (%s)\n", id, ITEM_TO_SEQ(item), to_binary(item)); 
        // possible-cv-signals;
        pthread_cond_signal(&prod_cond);
        // mutex-unlock;
        pthread_mutex_unlock(&mutex); 
        
        // apply this printf at the correct location in that pseudocode:
        //printf("%*s    C%d:%04x\n", 7*id, "", id, item); // write info to stdout (with indentation)
    }

    return(arg);
}

int main (void)
{
    pthread_t producer_thread;
    pthread_t consumer_threads[NROF_CONSUMERS];
    
    int i;

    // initialize consumer condition variables 
    pthread_cond_t cons_init = PTHREAD_COND_INITIALIZER;
    for (i = 0; i < NROF_CONSUMERS; i++) cons_cond[i] = cons_init;
        
    // startup the producer thread and the consumer threads
    pthread_create(&producer_thread, NULL, producer, NULL);
    printf("Producer thread created\n");
    for (i = 0; i < NROF_CONSUMERS; i++)
    {
        pthread_create(&consumer_threads[i], NULL, consumer, (void*) i);
    } 
    printf("Consumer thread created\n");
    
    // wait until all threads are finished  
    pthread_join(producer_thread, NULL);
    printf("Producer thread finished\n"); 
    for (i = 0; i < NROF_CONSUMERS; i++)
    {
        pthread_join(consumer_threads[i], NULL);
    }
    printf("Consumer threads finished\n");
    
    return (0);
}

/* used to print item in binary */
const char *to_binary(int x)
{
    static char b[17];
    b[0] = '\0';

    int z;
    for (z = 32768; z > 0; z >>= 1)
    {
        strcat(b, ((x & z) == z) ? "1" : "0");
    }
    return b;
}

/*
 * rsleep(int t)
 *
 * The calling thread will be suspended for a random amount of time between 0 and t microseconds
 * At the first call, the random generator is seeded with the current time
 */
static void rsleep (int t)
{
    static bool first_call = true;
    
    if (first_call == true)
    {
        srandom (time(NULL));
        first_call = false;
    }
    usleep (random () % t);
}

