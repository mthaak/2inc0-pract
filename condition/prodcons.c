/* 
 * Operating Systems  (2INC0)  Practical Assignment
 * Condition Variables Application
 *
 * Mark Bouwman (0868533)
 * Martin ter Haak (0846351)
 *
 * Grading:
 * Students who hand in clean code that fully satisfies the minimum requirements will get an 8. 
 * Extra steps can lead to higher marks because we want students to take the initiative. 
 * Extra steps can be, for example, in the form of measurements added to your code, a formal 
 * analysis of deadlock freeness etc.
 */
 
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <unistd.h>
#include <string.h>
#include <pthread.h>
#include "prodcons.h"

/* buffer[]
 * circular buffer that holds the items generated by the producer and
 * which have to be retrieved by consumers
 */
static ITEM     buffer [BUFFER_SIZE];

/* number of items currently in buffer */
static int      in_buffer = 0;

/* two 'pointers' to the position in the buffer */
int read_pointer = 0;
int write_pointer = 0;

/* whether all items are consumed */
static bool     consumer_finished = false;

static pthread_mutex_t              mutex                       = PTHREAD_MUTEX_INITIALIZER;

/* condition variable used to signal producer */
static pthread_cond_t               prod_cond                   = PTHREAD_COND_INITIALIZER;

/* condition variable to let producer know all items are consumed */
static pthread_cond_t               cons_finish                 = PTHREAD_COND_INITIALIZER;

/* condition variable to signal the various consumers */
static pthread_cond_t               cons_cond[NROF_CONSUMERS];

/* several operations to add or extract information from an item */
#define ITEM_MASK(seq_nr, dest)     (((seq_nr) << NROF_BITS_DEST) | dest) // create item
#define ITEM_TO_SEQ(mask)           (mask >> NROF_BITS_DEST)              // get sequence number from item
#define ITEM_TO_DEST(mask)          (mask & ((1 << NROF_BITS_DEST) - 1)   // get destination from item

static void rsleep (int t);

/* producer thread */
static void * producer (void * arg)
{
    ITEM    item;   // a produced item
    int total_produced = 1;
    
    while (total_produced <= NROF_ITEMS)
    {
        rsleep (PRODUCER_SLEEP_FACTOR);
        
        // produce new item
        short int dest_nr = rand() % NROF_CONSUMERS;
        item = ITEM_MASK(total_produced, dest_nr); 
       
        pthread_mutex_lock(&mutex); // mutex-lock
 
        // while not condition-for-this-producer
        while (in_buffer >= BUFFER_SIZE)
        {
            pthread_cond_wait(&prod_cond, &mutex);
        }
        buffer[write_pointer] = item; // put item into buffer
        printf("%04x\n", item); // print the item
        write_pointer = (write_pointer + 1) % BUFFER_SIZE; // point write pointer to next element in circular buffer
        in_buffer++;
        if (in_buffer == 1) { // signal consumer if buffer was empty
            pthread_cond_signal(&cons_cond[dest_nr]);
        }
        
        pthread_mutex_unlock(&mutex); // mutex-unlock
        total_produced++;
    }
    
    // inform consumers that we're ready
    pthread_mutex_lock(&mutex);
    if (NROF_ITEMS == 0) {
        consumer_finished = true;
    }
    while (consumer_finished == false) { // wait for the consumers to finish
        pthread_cond_wait(&cons_finish, &mutex); 
    }
    int i = 0;
    for (i = 0; i < NROF_CONSUMERS; i++) { // signall all consumers
        pthread_cond_signal(&cons_cond[i]); 
    }
    pthread_mutex_unlock(&mutex);

    return(arg);
}

/* consumer thread */
static void * consumer (void * arg)
{
    ITEM    item;   // a consumed item
    int     id;     // identifier of this consumer (value 0..NROF_CONSUMERS-1)
    
    id = (int) arg; 

    while (!consumer_finished)
    {
        rsleep (100 * NROF_CONSUMERS);

        pthread_mutex_lock(&mutex); // mutex-lock

        // while not condition-for-this-consumer
        while ((in_buffer <= 0) || consumer_finished || (ITEM_TO_DEST(buffer[read_pointer])) != id)) {
            if (consumer_finished) { // finish thread if we are finished
                pthread_mutex_unlock(&mutex); return(arg);
            }
            pthread_cond_wait(&cons_cond[id], &mutex); // wait-cv
        } 

        // get the next item from buffer (intended for this customer)
        item = buffer[read_pointer];
        printf("%*s    C%d:%04x\n", 7*id, "", id, item); // print info
        read_pointer = (read_pointer + 1) % BUFFER_SIZE; // let the read pointer point to next element
        in_buffer--; 

        // possible-cv-signals;
        if (in_buffer == (BUFFER_SIZE - 1)) { // signal producer if buffer was full
            pthread_cond_signal(&prod_cond);
        }
        if (in_buffer != 0) { // if there are more items signal consumer for which the next item is
            int next_dest;
            next_dest = ITEM_TO_DEST(buffer[read_pointer]));
            pthread_cond_signal(&cons_cond[next_dest]);
        }
        if (ITEM_TO_SEQ(item) == NROF_ITEMS) { //if the last item is consumed signal producer
            consumer_finished = true;
            pthread_cond_signal(&cons_finish);
        }

        pthread_mutex_unlock(&mutex); // mutex-unlock
    }

    return(arg);
}

int main (void)
{
    pthread_t producer_thread;
    pthread_t consumer_threads[NROF_CONSUMERS];
    
    int i;

    // initialize consumer condition variables 
    for (i = 0; i < NROF_CONSUMERS; i++) {
        pthread_cond_init(&cons_cond[i], NULL); 
    }
        
    // startup the producer thread and the consumer threads
    pthread_create(&producer_thread, NULL, producer, NULL);
    for (i = 0; i < NROF_CONSUMERS; i++)
    {
        pthread_create(&consumer_threads[i], NULL, consumer, (void*) i);
    } 
    
    // wait until all threads are finished  
    pthread_join(producer_thread, NULL); 
    for (i = 0; i < NROF_CONSUMERS; i++)
    {
        pthread_join(consumer_threads[i], NULL);
    }
    
    return (0);
}

/*
 * rsleep(int t)
 *
 * The calling thread will be suspended for a random amount of time between 0 and t microseconds
 * At the first call, the random generator is seeded with the current time
 */
static void rsleep (int t)
{
    static bool first_call = true;
    
    if (first_call == true)
    {
        srandom (time(NULL));
        first_call = false;
    }
    usleep (random () % t);
}

