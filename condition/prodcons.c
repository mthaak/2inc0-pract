/* 
 * Operating Systems  (2INC0)  Practical Assignment
 * Condition Variables Application
 *
 * STUDENT_NAME_1 (STUDENT_NR_1)
 * STUDENT_NAME_2 (STUDENT_NR_2)
 *
 * Grading:
 * Students who hand in clean code that fully satisfies the minimum requirements will get an 8. 
 * Extra steps can lead to higher marks because we want students to take the initiative. 
 * Extra steps can be, for example, in the form of measurements added to your code, a formal 
 * analysis of deadlock freeness etc.
 */
 
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

#include "prodcons.h"

/* buffer[]
 * circular buffer that holds the items generated by the producer and
 * which have to be retrieved by consumers
 */
static ITEM   buffer [BUFFER_SIZE];

static int    in_buffer = 0;

static pthread_mutex_t      mutex       = PTHREAD_MUTEX_INITIALIZER;
static pthread_cond_t       condition   = PTHREAD_COND_INITIALIZER;

#define BITS_MASK(seq_nr, dest)     ((seq_nr << NROF_BITS_DEST) || dest)

static void rsleep (int t);

/* producer thread */
static void * producer (void * arg)
{
    ITEM    item;   // a produced item
    int total_produced = 0;
    
    while (total_produced < NROF_ITEMS)
    {
        rsleep (PRODUCER_SLEEP_FACTOR);
        
        // TODO: 
        // * produce new item and put it into buffer[]
        // use shifting and masking to put a 'seq' and a 'dest' in an item
        // (see mask_test() in condition_basics.c how to create bit masks)
        //short int dest = rand() % NROF_CONSUMERS;
        short int dest_nr = 0;
        item = BITS_MASK(nr_produced, dest_nr);
        buffer[in_buffer] = item;
        in_buffer++;
        total_produced++;
        
       
        // follow this pseudocode (according to the ConditionSynchronization lecture):
        //      mutex-lock;
        pthread_mutex_lock(&mutex); 
        //      while not condition-for-this-producer
        while (in_buffer >= BUFFER_SIZE)
        {
            //          wait-cv;
            pthread_cond_wait(&condition, &mutex);
        }
        //      critical-section;
        //      possible-cv-signals;
        //      mutex-unlock;
        pthread_mutex_unlock(&mutex); 
        //
        // (see condition_test() in condition_basics.c how to use condition variables)

        // apply this printf at the correct location in that pseudocode:
        printf("%04x\n", item); // write info to stdout
    }
    
    // TODO: 
    // * inform consumers that we're ready
}

/* consumer thread */
static void * consumer (void * arg)
{
    ITEM    item;   // a consumed item
    int     id;     // identifier of this consumer (value 0..NROF_CONSUMERS-1)
    
    id = (int) arg;
    while (1/* TODO: not all items retrieved for this customer */)
    {
        rsleep (100 * NROF_CONSUMERS);

        // TODO: get the next item from buffer[] (intended for this customer)
        //
        // follow this pseudocode (according to the ConditionSynchronization lecture):
        //      mutex-lock;
        pthread_mutex_lock(&mutex);
        //      while not condition-for-this-consumer
        //          wait-cv;
        //      critical-section;
        //      possible-cv-signals;
        //      mutex-unlock;
        pthread_mutex_unlock(&mutex);

        // apply this printf at the correct location in that pseudocode:
        printf("%*s    C%d:%04x\n", 7*id, "", id, item); // write info to stdout (with indentation)
    }
}

int main (void)
{
    // TODO: 
    // * startup the producer thread and the consumer threads
    pthread producer_thread;
    pthread consumer_thread;
    //pthread consumer_threads[NROF_CONSUMERS];

    pthread_create(&producer_thread, NULL, producer, NULL);
    printf("Producer thread created");

    //int i;
    //for (i = 0; i < NROF_CONSUMERS; i++)
    //{
    //    pthread_create(&consumer_threads[i], NULL, consumer, NULL);
    //}
    pthread_create_(&consumer_thread, NULL, consumer, 0);
    printf("Consumer thread created");
    
    // * wait until all threads are finished  
    pthread_join(producer_thread, NULL);
    printf("Producer thread finished");

    //int i;
    //for (i = 0; i < NROF_CONSUMERS, i++)
    //{
    //    pthread_join(&consumer_threads[i], NULL);
    //}
    pthread_join(consumer_thread, NULL);
    printf("Consumer threads finished");
    
    return (0);
}

/*
 * rsleep(int t)
 *
 * The calling thread will be suspended for a random amount of time between 0 and t microseconds
 * At the first call, the random generator is seeded with the current time
 */
static void rsleep (int t)
{
    static bool first_call = true;
    
    if (first_call == true)
    {
        srandom (time(NULL));
        first_call = false;
    }
    usleep (random () % t);
}


